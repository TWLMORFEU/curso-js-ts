// Tipos de funções, e como cada uma se encaixa melhor





------Função normal (declaração padrão)-----

- Melhor para tarefas gerais.
- Boa legibilidade.
- Ideal quando o código precisa ser reusado várias vezes.
function somar(a, b) {
  return a + b;
}

- Use quando: quer criar uma função simples e reutilizável.




------Escopo Léxico-------

- A função enxerga variáveis de fora dela.
- O escopo é decidido no momento da criação, não da execução.
function externa() {
  const nome = 'Eduardo';

  function interna() {
    console.log(nome); // Enxerga por escopo léxico
  }

  interna();
}
- Use quando: precisa acessar variáveis externas sem passá-las como parâmetro.




-------Closure------

-Permite guardar valores na memória, mesmo após a função “acabar”.
-Cria variáveis privadas (ninguém acessa de fora).
function contador() {
  let num = 0;

  return function() {
    num++;
    console.log(num);
  };
}

const c = contador();
c(); // 1
c(); // 2
c(); // 3
- Use quando: quiser proteger dados ou preservar valores.
- Muito usado para segurança, performance e encapsulamento.




-------Callback-------

- Uma função passada como argumento para outra.
- Útil para eventos, ações do usuário, espera de tempo, AJAX…

function fazerAlgo(callback) {
  console.log('Fazendo...');
  callback(); // executa depois
}

fazerAlgo(() => console.log('Feito!'));


- Use quando: algo depende de outra ação (eventos, tempo, carregamento…).
- Muito usado em JavaScript assíncrono.




-------IIFE — Função Imediata-------

- Executa imediatamente.
- Protege escopo (cria um “mundo fechado”).

(function() {
  const nome = 'Eduardo';
  console.log(nome);
})();


- Use quando: quer rodar código sem poluir o escopo global.



------Factory Function------
- Cria objetos com lógica interna e dados protegidos (privados).
- Flexível — não depende de new.

function criaPessoa(nome, idade) {
  return {
    nome,
    idade,
    falar() {
      console.log(`Olá! Meu nome é ${nome}`);
    }
  };
}

const p1 = criaPessoa('Eduardo', 18);
p1.falar();


- Use quando: precisa criar vários objetos com lógica especial.
- Boa para modularização — MUITO usada em projetos reais.




-------Funções Construtoras-------

- Parecida com a factory, mas otimizada para performance.
- Mais próxima da orientação a objetos (OO).

function Pessoa(nome, idade) {
  this.nome = nome;
  this.idade = idade;
}

const p1 = new Pessoa('Eduardo', 18);


- Use quando: precisa criar muitos objetos e performance importa.
- Melhor com prototype → economiza memória.





--------Função Recursiva-------

- Quando uma função chama ela mesma.
- Substitui laços de repetição em problemas complexos.

function contagem(n) {
  if (n === 0) return;
  console.log(n);
  contagem(n - 1);
}

contagem(5);


- Use quando: o problema pode ser dividido em partes menores.
- Árvores, fatorial, estruturas matemáticas.





--------Funções geradoras--------

- Permitem pausar e continuar a execução.
- Controle TOTAL do fluxo (yield).

function* gerador() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gerador();
console.log(g.next().value); // 1
console.log(g.next().value); // 2


- Use quando: quiser controlar passo a passo o código
- Útil em simulações, jogos, fluxos lógicos, leitura de dados grandes…








****************** RESUMO *****************

Precisa de…	                        Melhor função
Executar um código só uma vez   	IIFE
Criar objetos com lógica	        Factory
Criar muitos objetos iguais	        Construtora
Controlar uma ação no tempo	        Callback
Criar memória privada	            Closure
Repetição inteligente	            Recursiva
Controle total da execução	        Geradora
Função simples e geral	            Declaração normal